// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: role.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addPermissionsToRole = `-- name: AddPermissionsToRole :execrows
insert into role_permissions (role_id, perm_id)
select $1, unnest($2::UUID[])
where not exists (
    select 1
    from role_permissions
    where role_id = $1 and perm_id = any($2::UUID[])
)
`

type AddPermissionsToRoleParams struct {
	RoleID  pgtype.UUID
	Column2 []pgtype.UUID
}

func (q *Queries) AddPermissionsToRole(ctx context.Context, arg AddPermissionsToRoleParams) (int64, error) {
	result, err := q.db.Exec(ctx, addPermissionsToRole, arg.RoleID, arg.Column2)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const countRootRoles = `-- name: CountRootRoles :one
select count(role_id) as total
from roles
where is_root = true and
($1::TEXT IS NULL OR $1::TEXT = '' OR name ILIKE '%' || $1::TEXT || '%')
`

func (q *Queries) CountRootRoles(ctx context.Context, dollar_1 string) (int64, error) {
	row := q.db.QueryRow(ctx, countRootRoles, dollar_1)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countTotalRoles = `-- name: CountTotalRoles :one
select count(role_id) as total
from roles
Where
($1::TEXT IS NULL OR $1::TEXT = '' OR name ILIKE '%' || $1::TEXT || '%')
`

func (q *Queries) CountTotalRoles(ctx context.Context, dollar_1 string) (int64, error) {
	row := q.db.QueryRow(ctx, countTotalRoles, dollar_1)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countUsersByRoles = `-- name: CountUsersByRoles :many
select r.role_id, count(ur.user_id) as total_users
from roles r
left join user_roles ur on r.role_id = ur.role_id
where r.role_id = any($1::uuid[])
group by r.role_id
`

type CountUsersByRolesRow struct {
	RoleID     pgtype.UUID
	TotalUsers int64
}

func (q *Queries) CountUsersByRoles(ctx context.Context, dollar_1 []pgtype.UUID) ([]CountUsersByRolesRow, error) {
	rows, err := q.db.Query(ctx, countUsersByRoles, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CountUsersByRolesRow
	for rows.Next() {
		var i CountUsersByRolesRow
		if err := rows.Scan(&i.RoleID, &i.TotalUsers); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteRole = `-- name: DeleteRole :execrows
DELETE FROM roles
WHERE role_id = $1 and is_root = false
`

func (q *Queries) DeleteRole(ctx context.Context, roleID pgtype.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deleteRole, roleID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const disableOrEnableRole = `-- name: DisableOrEnableRole :execrows
UPDATE roles
SET is_active = NOT is_active
WHERE role_id = $1 and is_root = false
`

func (q *Queries) DisableOrEnableRole(ctx context.Context, roleID pgtype.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, disableOrEnableRole, roleID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getPermissionIdsByRole = `-- name: GetPermissionIdsByRole :many
select perm_id
from role_permissions
where role_id = $1
`

func (q *Queries) GetPermissionIdsByRole(ctx context.Context, roleID pgtype.UUID) ([]pgtype.UUID, error) {
	rows, err := q.db.Query(ctx, getPermissionIdsByRole, roleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.UUID
	for rows.Next() {
		var perm_id pgtype.UUID
		if err := rows.Scan(&perm_id); err != nil {
			return nil, err
		}
		items = append(items, perm_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoleById = `-- name: GetRoleById :many
select 
    r.role_id as role_id,
    r.name as role_name,
    r.description,
    r.is_root,
    r.created_at,
    r.updated_at,
    r.is_active,
    p.perm_id as permission_id,
    p.name as permission_name,
    p.description as permission_description
from roles r
left join role_permissions rp on r.role_id = rp.role_id
left join permissions p on rp.perm_id = p.perm_id
where r.role_id = $1
`

type GetRoleByIdRow struct {
	RoleID                pgtype.UUID
	RoleName              string
	Description           pgtype.Text
	IsRoot                bool
	CreatedAt             pgtype.Timestamptz
	UpdatedAt             pgtype.Timestamptz
	IsActive              bool
	PermissionID          pgtype.UUID
	PermissionName        pgtype.Text
	PermissionDescription pgtype.Text
}

func (q *Queries) GetRoleById(ctx context.Context, roleID pgtype.UUID) ([]GetRoleByIdRow, error) {
	rows, err := q.db.Query(ctx, getRoleById, roleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRoleByIdRow
	for rows.Next() {
		var i GetRoleByIdRow
		if err := rows.Scan(
			&i.RoleID,
			&i.RoleName,
			&i.Description,
			&i.IsRoot,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsActive,
			&i.PermissionID,
			&i.PermissionName,
			&i.PermissionDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoleByName = `-- name: GetRoleByName :one
select role_id, name, is_root, is_active, description
from roles
where name = $1
`

type GetRoleByNameRow struct {
	RoleID      pgtype.UUID
	Name        string
	IsRoot      bool
	IsActive    bool
	Description pgtype.Text
}

func (q *Queries) GetRoleByName(ctx context.Context, name string) (GetRoleByNameRow, error) {
	row := q.db.QueryRow(ctx, getRoleByName, name)
	var i GetRoleByNameRow
	err := row.Scan(
		&i.RoleID,
		&i.Name,
		&i.IsRoot,
		&i.IsActive,
		&i.Description,
	)
	return i, err
}

const getRoles = `-- name: GetRoles :many
select role_id, name, is_root, is_active, description
from roles
Where
($1::TEXT IS NULL OR $1::TEXT = '' OR name ILIKE '%' || $1::TEXT || '%')
Order by created_at desc
LIMIT NULLIF($2, 0)
OFFSET CASE WHEN $3::INT IS NULL OR $3::INT < 0 THEN 0 ELSE $3::INT END
`

type GetRolesParams struct {
	Column1 string
	Column2 interface{}
	Column3 int32
}

type GetRolesRow struct {
	RoleID      pgtype.UUID
	Name        string
	IsRoot      bool
	IsActive    bool
	Description pgtype.Text
}

func (q *Queries) GetRoles(ctx context.Context, arg GetRolesParams) ([]GetRolesRow, error) {
	rows, err := q.db.Query(ctx, getRoles, arg.Column1, arg.Column2, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRolesRow
	for rows.Next() {
		var i GetRolesRow
		if err := rows.Scan(
			&i.RoleID,
			&i.Name,
			&i.IsRoot,
			&i.IsActive,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertRole = `-- name: InsertRole :one
insert into roles (name, description)
values ($1, $2)
returning role_id
`

type InsertRoleParams struct {
	Name        string
	Description pgtype.Text
}

func (q *Queries) InsertRole(ctx context.Context, arg InsertRoleParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, insertRole, arg.Name, arg.Description)
	var role_id pgtype.UUID
	err := row.Scan(&role_id)
	return role_id, err
}

const isRootRole = `-- name: IsRootRole :one
select is_root
from roles
where role_id = $1
`

func (q *Queries) IsRootRole(ctx context.Context, roleID pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, isRootRole, roleID)
	var is_root bool
	err := row.Scan(&is_root)
	return is_root, err
}

const removePermissionsFromRole = `-- name: RemovePermissionsFromRole :execrows
delete from role_permissions
where role_id = $1 and perm_id = any($2::uuid[])
`

type RemovePermissionsFromRoleParams struct {
	RoleID  pgtype.UUID
	Column2 []pgtype.UUID
}

func (q *Queries) RemovePermissionsFromRole(ctx context.Context, arg RemovePermissionsFromRoleParams) (int64, error) {
	result, err := q.db.Exec(ctx, removePermissionsFromRole, arg.RoleID, arg.Column2)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateRole = `-- name: UpdateRole :execrows
update roles
set name = $1, description = $2
where role_id = $3 and is_root = false
`

type UpdateRoleParams struct {
	Name        string
	Description pgtype.Text
	RoleID      pgtype.UUID
}

func (q *Queries) UpdateRole(ctx context.Context, arg UpdateRoleParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateRole, arg.Name, arg.Description, arg.RoleID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
