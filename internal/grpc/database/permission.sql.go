// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: permission.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addActionToPermission = `-- name: AddActionToPermission :exec
INSERT INTO permission_actions (perm_id, action_id)
SELECT $1, unnest($2::TEXT[])
WHERE NOT EXISTS (
    SELECT 1
    FROM permission_actions
    WHERE perm_id = $1 AND action_id = ANY($2::TEXT[])
)
`

type AddActionToPermissionParams struct {
	PermID  pgtype.UUID
	Column2 []string
}

func (q *Queries) AddActionToPermission(ctx context.Context, arg AddActionToPermissionParams) error {
	_, err := q.db.Exec(ctx, addActionToPermission, arg.PermID, arg.Column2)
	return err
}

const countRootPermissions = `-- name: CountRootPermissions :one
select count(perm_id) as total
from permissions
where is_root = true and
($1::TEXT IS NULL OR $1::TEXT = '' OR name ILIKE '%' || $1::TEXT || '%') AND
($2::TEXT IS NULL OR $2::TEXT = '' OR resource_id = $2::TEXT)
`

type CountRootPermissionsParams struct {
	Column1 string
	Column2 string
}

func (q *Queries) CountRootPermissions(ctx context.Context, arg CountRootPermissionsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countRootPermissions, arg.Column1, arg.Column2)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countTotalPermissions = `-- name: CountTotalPermissions :one
select count(perm_id) as total
from permissions
Where
($1::TEXT IS NULL OR $1::TEXT = '' OR name ILIKE '%' || $1::TEXT || '%') AND
($2::TEXT IS NULL OR $2::TEXT = '' OR resource_id = $2::TEXT)
`

type CountTotalPermissionsParams struct {
	Column1 string
	Column2 string
}

func (q *Queries) CountTotalPermissions(ctx context.Context, arg CountTotalPermissionsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countTotalPermissions, arg.Column1, arg.Column2)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const deleteActionToPermission = `-- name: DeleteActionToPermission :exec
DELETE FROM permission_actions
WHERE perm_id = $1 AND action_id = ANY($2::TEXT[])
`

type DeleteActionToPermissionParams struct {
	PermID  pgtype.UUID
	Column2 []string
}

func (q *Queries) DeleteActionToPermission(ctx context.Context, arg DeleteActionToPermissionParams) error {
	_, err := q.db.Exec(ctx, deleteActionToPermission, arg.PermID, arg.Column2)
	return err
}

const deletePermission = `-- name: DeletePermission :exec
delete from permissions
where perm_id = $1 and is_root = false
`

func (q *Queries) DeletePermission(ctx context.Context, permID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deletePermission, permID)
	return err
}

const getActions = `-- name: GetActions :many
select action_id, name
from actions
where resource_id = $1
`

type GetActionsRow struct {
	ActionID string
	Name     string
}

func (q *Queries) GetActions(ctx context.Context, resourceID string) ([]GetActionsRow, error) {
	rows, err := q.db.Query(ctx, getActions, resourceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetActionsRow
	for rows.Next() {
		var i GetActionsRow
		if err := rows.Scan(&i.ActionID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActionsByPermissionId = `-- name: GetActionsByPermissionId :many
select pa.pa_id, pa.action_id
from permission_actions pa
where pa.perm_id = $1
`

type GetActionsByPermissionIdRow struct {
	PaID     pgtype.UUID
	ActionID string
}

func (q *Queries) GetActionsByPermissionId(ctx context.Context, permID pgtype.UUID) ([]GetActionsByPermissionIdRow, error) {
	rows, err := q.db.Query(ctx, getActionsByPermissionId, permID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetActionsByPermissionIdRow
	for rows.Next() {
		var i GetActionsByPermissionIdRow
		if err := rows.Scan(&i.PaID, &i.ActionID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPermission = `-- name: GetPermission :many
SELECT
    p.perm_id,
    p.name AS permission_name,
    p.resource_id,
    p.is_root,
    r.name AS resource_name,
    p.description,
    p.updated_at,
    p.created_at,
    a.action_id,
    a.name AS action_name
FROM permissions p
JOIN resources r ON r.resource_id = p.resource_id
LEFT JOIN permission_actions pa ON pa.perm_id = p.perm_id
LEFT JOIN actions a ON a.action_id = pa.action_id
WHERE p.perm_id = $1
`

type GetPermissionRow struct {
	PermID         pgtype.UUID
	PermissionName string
	ResourceID     string
	IsRoot         bool
	ResourceName   string
	Description    pgtype.Text
	UpdatedAt      pgtype.Timestamptz
	CreatedAt      pgtype.Timestamptz
	ActionID       pgtype.Text
	ActionName     pgtype.Text
}

func (q *Queries) GetPermission(ctx context.Context, permID pgtype.UUID) ([]GetPermissionRow, error) {
	rows, err := q.db.Query(ctx, getPermission, permID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPermissionRow
	for rows.Next() {
		var i GetPermissionRow
		if err := rows.Scan(
			&i.PermID,
			&i.PermissionName,
			&i.ResourceID,
			&i.IsRoot,
			&i.ResourceName,
			&i.Description,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.ActionID,
			&i.ActionName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPermissions = `-- name: GetPermissions :many
select perm_id, name, is_root, description
from permissions
Where
($1::TEXT IS NULL OR $1::TEXT = '' OR name ILIKE '%' || $1::TEXT || '%') AND
($2::TEXT IS NULL OR $2::TEXT = '' OR resource_id = $2::TEXT)
Order by created_at desc
LIMIT NULLIF($3, 0)
OFFSET CASE WHEN $4::INT IS NULL OR $4::INT < 0 THEN 0 ELSE $4::INT END
`

type GetPermissionsParams struct {
	Column1 string
	Column2 string
	Column3 interface{}
	Column4 int32
}

type GetPermissionsRow struct {
	PermID      pgtype.UUID
	Name        string
	IsRoot      bool
	Description pgtype.Text
}

func (q *Queries) GetPermissions(ctx context.Context, arg GetPermissionsParams) ([]GetPermissionsRow, error) {
	rows, err := q.db.Query(ctx, getPermissions,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPermissionsRow
	for rows.Next() {
		var i GetPermissionsRow
		if err := rows.Scan(
			&i.PermID,
			&i.Name,
			&i.IsRoot,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getResources = `-- name: GetResources :many
select resource_id, name
from resources
`

type GetResourcesRow struct {
	ResourceID string
	Name       string
}

func (q *Queries) GetResources(ctx context.Context) ([]GetResourcesRow, error) {
	rows, err := q.db.Query(ctx, getResources)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetResourcesRow
	for rows.Next() {
		var i GetResourcesRow
		if err := rows.Scan(&i.ResourceID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertPermission = `-- name: InsertPermission :one
INSERT INTO permissions (name, resource_id, description)
VALUES ($1, $2, $3)
RETURNING perm_id
`

type InsertPermissionParams struct {
	Name        string
	ResourceID  string
	Description pgtype.Text
}

func (q *Queries) InsertPermission(ctx context.Context, arg InsertPermissionParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, insertPermission, arg.Name, arg.ResourceID, arg.Description)
	var perm_id pgtype.UUID
	err := row.Scan(&perm_id)
	return perm_id, err
}

const updatePermission = `-- name: UpdatePermission :one
UPDATE permissions
SET name = $2,
    resource_id = $3,
    description = $4
WHERE perm_id = $1
RETURNING perm_id
`

type UpdatePermissionParams struct {
	PermID      pgtype.UUID
	Name        string
	ResourceID  string
	Description pgtype.Text
}

func (q *Queries) UpdatePermission(ctx context.Context, arg UpdatePermissionParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, updatePermission,
		arg.PermID,
		arg.Name,
		arg.ResourceID,
		arg.Description,
	)
	var perm_id pgtype.UUID
	err := row.Scan(&perm_id)
	return perm_id, err
}
