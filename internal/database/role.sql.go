// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: role.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countRootRoles = `-- name: CountRootRoles :one
select count(role_id) as total
from roles
where is_root = true and
($1::TEXT IS NULL OR $1::TEXT = '' OR name ILIKE '%' || $1::TEXT || '%')
`

func (q *Queries) CountRootRoles(ctx context.Context, dollar_1 string) (int64, error) {
	row := q.db.QueryRow(ctx, countRootRoles, dollar_1)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countTotalRoles = `-- name: CountTotalRoles :one
select count(role_id) as total
from roles
Where
($1::TEXT IS NULL OR $1::TEXT = '' OR name ILIKE '%' || $1::TEXT || '%')
`

func (q *Queries) CountTotalRoles(ctx context.Context, dollar_1 string) (int64, error) {
	row := q.db.QueryRow(ctx, countTotalRoles, dollar_1)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const countUsersByRoles = `-- name: CountUsersByRoles :many
select r.role_id, count(ur.user_id) as total_users
from roles r
left join user_roles ur on r.role_id = ur.role_id
where r.role_id = any($1::uuid[])
group by r.role_id
`

type CountUsersByRolesRow struct {
	RoleID     pgtype.UUID
	TotalUsers int64
}

func (q *Queries) CountUsersByRoles(ctx context.Context, dollar_1 []pgtype.UUID) ([]CountUsersByRolesRow, error) {
	rows, err := q.db.Query(ctx, countUsersByRoles, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CountUsersByRolesRow
	for rows.Next() {
		var i CountUsersByRolesRow
		if err := rows.Scan(&i.RoleID, &i.TotalUsers); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteRole = `-- name: DeleteRole :execrows
DELETE FROM roles
WHERE role_id = $1 and is_root = false
`

func (q *Queries) DeleteRole(ctx context.Context, roleID pgtype.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deleteRole, roleID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const disableOrEnableRole = `-- name: DisableOrEnableRole :execrows
UPDATE roles
SET is_active = NOT is_active
WHERE role_id = $1 and is_root = false
`

func (q *Queries) DisableOrEnableRole(ctx context.Context, roleID pgtype.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, disableOrEnableRole, roleID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getRoleById = `-- name: GetRoleById :many
select 
    r.role_id as role_id,
    r.name as role_name,
    r.description,
    r.is_root,
    r.created_at,
    r.updated_at,
    r.is_active,
    p.perm_id as permission_id,
    p.name as permission_name,
    p.description as permission_description
from roles r
left join role_permissions rp on r.role_id = rp.role_id
left join permissions p on rp.perm_id = p.perm_id
where r.role_id = $1
`

type GetRoleByIdRow struct {
	RoleID                pgtype.UUID
	RoleName              string
	Description           pgtype.Text
	IsRoot                bool
	CreatedAt             pgtype.Timestamp
	UpdatedAt             pgtype.Timestamp
	IsActive              bool
	PermissionID          pgtype.UUID
	PermissionName        pgtype.Text
	PermissionDescription pgtype.Text
}

func (q *Queries) GetRoleById(ctx context.Context, roleID pgtype.UUID) ([]GetRoleByIdRow, error) {
	rows, err := q.db.Query(ctx, getRoleById, roleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRoleByIdRow
	for rows.Next() {
		var i GetRoleByIdRow
		if err := rows.Scan(
			&i.RoleID,
			&i.RoleName,
			&i.Description,
			&i.IsRoot,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsActive,
			&i.PermissionID,
			&i.PermissionName,
			&i.PermissionDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoles = `-- name: GetRoles :many
select role_id, name, is_root, is_active, description
from roles
Where
($1::TEXT IS NULL OR $1::TEXT = '' OR name ILIKE '%' || $1::TEXT || '%')
Order by role_id
limit $2 offset $3
`

type GetRolesParams struct {
	Column1 string
	Limit   int32
	Offset  int32
}

type GetRolesRow struct {
	RoleID      pgtype.UUID
	Name        string
	IsRoot      bool
	IsActive    bool
	Description pgtype.Text
}

func (q *Queries) GetRoles(ctx context.Context, arg GetRolesParams) ([]GetRolesRow, error) {
	rows, err := q.db.Query(ctx, getRoles, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRolesRow
	for rows.Next() {
		var i GetRolesRow
		if err := rows.Scan(
			&i.RoleID,
			&i.Name,
			&i.IsRoot,
			&i.IsActive,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
