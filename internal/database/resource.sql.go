// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: resource.sql

package database

import (
	"context"
)

const deleteActionNotInUse = `-- name: DeleteActionNotInUse :exec
DELETE FROM actions
WHERE action_id NOT IN (
  SELECT UNNEST($1::text[])
)
`

func (q *Queries) DeleteActionNotInUse(ctx context.Context, dollar_1 []string) error {
	_, err := q.db.Exec(ctx, deleteActionNotInUse, dollar_1)
	return err
}

const deleteResourceNotInUse = `-- name: DeleteResourceNotInUse :exec
DELETE FROM resources
WHERE resource_id NOT IN (
  SELECT UNNEST($1::text[])
)
`

func (q *Queries) DeleteResourceNotInUse(ctx context.Context, dollar_1 []string) error {
	_, err := q.db.Exec(ctx, deleteResourceNotInUse, dollar_1)
	return err
}

const upsertActionByID = `-- name: UpsertActionByID :exec
INSERT INTO actions (action_id, name, resource_id)
VALUES ($1, $2, $3)
ON CONFLICT (action_id) DO UPDATE
SET name = EXCLUDED.name,
    resource_id = EXCLUDED.resource_id
WHERE actions.name IS DISTINCT FROM EXCLUDED.name
  OR actions.resource_id IS DISTINCT FROM EXCLUDED.resource_id
`

type UpsertActionByIDParams struct {
	ActionID   string
	Name       string
	ResourceID string
}

func (q *Queries) UpsertActionByID(ctx context.Context, arg UpsertActionByIDParams) error {
	_, err := q.db.Exec(ctx, upsertActionByID, arg.ActionID, arg.Name, arg.ResourceID)
	return err
}

const upsertResourceByID = `-- name: UpsertResourceByID :exec
INSERT INTO resources (resource_id, name)
VALUES ($1, $2)
ON CONFLICT (resource_id) DO UPDATE
SET name = EXCLUDED.name
WHERE resources.name IS DISTINCT FROM EXCLUDED.name
`

type UpsertResourceByIDParams struct {
	ResourceID string
	Name       string
}

func (q *Queries) UpsertResourceByID(ctx context.Context, arg UpsertResourceByIDParams) error {
	_, err := q.db.Exec(ctx, upsertResourceByID, arg.ResourceID, arg.Name)
	return err
}
